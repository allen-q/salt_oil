{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "IUnFr6MO3Kk3"
   },
   "source": [
    "# Changes:\n",
    "1. Removed images with ambigous mask or too few salt pix\n",
    "2. Over sample low IOU images."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "xaO5fG0VW5gB"
   },
   "source": [
    "## Install required packages if running on google colab"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 877
    },
    "colab_type": "code",
    "id": "8n6EgF7sW5gC",
    "outputId": "85126ec3-1826-4611-996b-ca5a4cfaba58"
   },
   "outputs": [],
   "source": [
    "try:\n",
    "    import torch\n",
    "except:\n",
    "    !pip install torch torchvision\n",
    "    !pip install imageio\n",
    "    !pip install Augmentor\n",
    "    !git clone https://github.com/allen-q/salt_oil.git\n",
    "    !git clone https://github.com/allen-q/salt_net.git"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "id": "p3h4PngQ0s86",
    "outputId": "4ed07b85-6f25-49d6-80f4-9629eb9b383f"
   },
   "outputs": [],
   "source": [
    "cd salt_oil/"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "UVnBJygnW5gK"
   },
   "source": [
    "## Import required libs"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "x1VSamfH3Kk6"
   },
   "outputs": [],
   "source": [
    "import zipfile\n",
    "import torch\n",
    "import torchvision\n",
    "import torch.nn as nn\n",
    "import torch.nn.functional as F\n",
    "from torch.utils import data\n",
    "from torch.utils.data import Dataset, DataLoader\n",
    "from torchvision import transforms, utils\n",
    "from skimage import io, transform\n",
    "from sklearn.model_selection import train_test_split\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as ply\n",
    "import os\n",
    "import imageio\n",
    "from PIL import Image\n",
    "import glob\n",
    "import matplotlib.pyplot as plt\n",
    "import time\n",
    "import math\n",
    "import datetime as dt\n",
    "import pytz\n",
    "import pickle\n",
    "from salt_func_lib import *\n",
    "from torchvision import transforms, utils\n",
    "from skimage import io, transform\n",
    "import datetime as dt\n",
    "import sys\n",
    "from optparse import OptionParser\n",
    "import torch.backends.cudnn as cudnn\n",
    "from torch import optim\n",
    "from torch.optim import lr_scheduler\n",
    "import copy\n",
    "from io import BytesIO\n",
    "import Augmentor\n",
    "import random\n",
    "import PIL\n",
    "% matplotlib inline\n",
    "% load_ext autoreload\n",
    "% autoreload 2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "I87qLhAOW5gO"
   },
   "source": [
    "## Load Unet Modules"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "eC32auGDqVZi"
   },
   "outputs": [],
   "source": [
    "from pytorch_unet.eval import eval_net\n",
    "from pytorch_unet.unet import UNet\n",
    "from pytorch_unet.unet.unet_parts import *\n",
    "from pytorch_unet.utils import get_ids, split_ids, split_train_val, get_imgs_and_masks, batch"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "6O8Wz9H_iTDE"
   },
   "outputs": [],
   "source": [
    "## Setup data type based on whether GPU is enabled"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "QKYhIfCtEk6C"
   },
   "outputs": [],
   "source": [
    "if torch.cuda.is_available():\n",
    "    dtype = torch.cuda.FloatTensor ## UNCOMMENT THIS LINE IF YOU'RE ON A GPU!\n",
    "else:    \n",
    "    dtype = torch.FloatTensor"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "id": "51wk3a_bTtv-",
    "outputId": "a00aaac6-9864-42da-8e1a-b47f03e89625"
   },
   "outputs": [],
   "source": [
    "print(f'Data Type set to: {dtype}')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "30EV6nbKbtyV"
   },
   "source": [
    "## Create Global Variables"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "8zcHyi6AMfDf"
   },
   "outputs": [],
   "source": [
    "def init_global_variables():\n",
    "    \"\"\"initialize global variables such as db connection, logger etc.\"\"\"\n",
    "    global log\n",
    "    log = get_logger('SaltNet')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "CLILkc8Vbtya"
   },
   "outputs": [],
   "source": [
    "init_global_variables()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "KwNexNnZxQ7k"
   },
   "outputs": [],
   "source": [
    "class SaltDataset(Dataset):\n",
    "    \"\"\"Face Landmarks dataset.\"\"\"\n",
    "\n",
    "    def __init__(self, np_img, np_mask, df_depth, mean_img, out_size=101, out_ch=1, transform=None):\n",
    "        \"\"\"\n",
    "        Args:\n",
    "            data_dir (string): Path to the image files.\n",
    "            train (bool): Load train or test data\n",
    "            transform (callable, optional): Optional transform to be applied\n",
    "                on a sample.\n",
    "        \"\"\"\n",
    "        self.np_img = np_img\n",
    "        self.np_mask = np_mask.clip(0,1)\n",
    "        self.df_depth = df_depth\n",
    "        self.mean_img = mean_img\n",
    "        self.out_size = out_size\n",
    "        self.out_ch = out_ch\n",
    "        self.transform = transform\n",
    "\n",
    "    def __len__(self):\n",
    "        return len(self.np_img)\n",
    "\n",
    "    def __getitem__(self, idx):\n",
    "        if isinstance(idx, torch.Tensor):\n",
    "            idx = idx.item()\n",
    "            \n",
    "        X_orig = self.np_img[idx]\n",
    "        #X = X_orig - self.mean_img\n",
    "\n",
    "        if self.np_mask is None:\n",
    "            y = np.zeros((101,101,1))\n",
    "        else:\n",
    "            y = self.np_mask[idx]\n",
    "\n",
    "        if self.transform:\n",
    "            img_in = PIL.Image.fromarray(np.c_[np.tile(X_orig, 2), y*255])\n",
    "            #img_in = PIL.Image.fromarray(np.tile(y, 3)*255)\n",
    "            transformed = np.array(self.transform(img_in))\n",
    "            X = np.clip(transformed[:,:,0:1]/255, 0., 1.) - self.mean_img\n",
    "            y = np.clip(transformed[:,:,2:3]/255, 0., 1.)\n",
    "        else:\n",
    "            X = np.clip(X_orig/255, 0., 1.) - self.mean_img\n",
    "\n",
    "        #print(X.dtype)\n",
    "        \n",
    "        X = np.moveaxis(X, -1,0)\n",
    "\n",
    "        pad_size = self.out_size - X.shape[2]\n",
    "        pad_first = pad_size//2\n",
    "        pad_last = pad_size - pad_first\n",
    "        X = np.pad(X, [(0, 0),(pad_first, pad_last), (pad_first, pad_last)], mode='reflect')\n",
    "        #print(X.dtype)\n",
    "\n",
    "        #from boxx import g\n",
    "        #g()\n",
    "\n",
    "        d = self.df_depth.iloc[idx,0]\n",
    "        #id = self.df_depth.index[idx]\n",
    "        #from boxx import g\n",
    "        #g()\n",
    "        X = torch.from_numpy(X).float().type(dtype)\n",
    "        X = X.repeat(self.out_ch,1,1)\n",
    "        y = transform.resize(y, (101, 101), mode='constant', preserve_range=True)\n",
    "        y = torch.from_numpy(y).float().squeeze().type(dtype)\n",
    "\n",
    "        return (X,y,d,idx)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "Q0_gBiSvxQ7n"
   },
   "outputs": [],
   "source": [
    "class Pipeline_Salt(Augmentor.Pipeline):\n",
    "    def __init__(self, source_directory=None, output_directory=\"output\", save_format=None):\n",
    "        super(Pipeline_Salt, self).__init__(source_directory, output_directory, save_format)\n",
    "\n",
    "    def torch_transform(self):\n",
    "        \"\"\"\n",
    "        Returns the pipeline as a function that can be used with torchvision.\n",
    "\n",
    "        .. code-block:: python\n",
    "\n",
    "            >>> import Augmentor\n",
    "            >>> import torchvision\n",
    "            >>> p = Augmentor.Pipeline()\n",
    "            >>> p.rotate(probability=0.7, max_left_rotate=10, max_right_rotate=10)\n",
    "            >>> p.zoom(probability=0.5, min_factor=1.1, max_factor=1.5)\n",
    "            >>> transforms = torchvision.transforms.Compose([\n",
    "            >>>     p.torch_transform(),\n",
    "            >>>     torchvision.transforms.ToTensor(),\n",
    "            >>> ])\n",
    "\n",
    "        :return: The pipeline as a function.\n",
    "        \"\"\"\n",
    "        def _transform(image):\n",
    "            for operation in self.operations:\n",
    "                r = round(random.uniform(0, 1), 1)\n",
    "                if r <= operation.probability:\n",
    "                    if not isinstance(image, list):\n",
    "                        image = [image]\n",
    "                    image = operation.perform_operation(image)[0]\n",
    "\n",
    "            return image\n",
    "\n",
    "        return _transform"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "aEXPdEFd3KmA"
   },
   "source": [
    "## Prepare Data"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "53yVOPsQ3KmB"
   },
   "source": [
    "### Load train and test data from npy files or from raw images if npy files not exist."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 50
    },
    "colab_type": "code",
    "id": "wO1kf6HW3KmC",
    "outputId": "8e264ddf-999f-4110-bb08-6cd83c58af0e"
   },
   "outputs": [],
   "source": [
    "np_train_all, np_train_all_mask, X_test, misc_data = load_all_data()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Calculate number of mask pixels per image"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df_train_mask = pd.DataFrame((np_train_all_mask/255).sum((1,2,3)), columns=['mask_pix'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df_train_mask.mask_pix = df_train_mask.mask_pix.round(-2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "mask_pix_bins = df_train_mask.mask_pix.sort_values().unique()\n",
    "# Due to zooming and crop, under-sample all black and all white masks, over-sample images with small mask areas.\n",
    "mask_pix_bin_weights = ([1.] + np.r_[3:1:102j].tolist() + [0.2])\n",
    "mask_pix_bin_weights = dict(zip(mask_pix_bins, mask_pix_bin_weights))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "train_all_sample_weight = df_train_mask.mask_pix.map(mask_pix_bin_weights)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "scrolled": false
   },
   "outputs": [],
   "source": [
    "#np.log10(df_train_mask.mask_pix.div(100).add(10))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "BTkpzBqmGRN2"
   },
   "source": [
    "### Remove black images"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "8BXkNsiZGRN3"
   },
   "outputs": [],
   "source": [
    "#black_img_ids = (np_train_all.max((1,2,3))==0)\n",
    "\n",
    "#np_train_all = np_train_all[~black_img_ids]\n",
    "#np_train_all_mask = np_train_all_mask[~black_img_ids]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "id": "obPeKNjDGRN6",
    "outputId": "5feebc67-976e-434b-d4b7-beca2cc4bd9a"
   },
   "outputs": [],
   "source": [
    "np_train_all.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "DZqPs7VnYd56"
   },
   "source": [
    "### Remove images with all black masks"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "lzqSzGzEYd5-"
   },
   "outputs": [],
   "source": [
    "#black_mask_ids = (np_train_all_mask.max((1,2,3))==0)\n",
    "#np_train_all = np_train_all[~black_mask_ids]\n",
    "#np_train_all_mask = np_train_all_mask[~black_mask_ids]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "DNIS7zT23KmI"
   },
   "source": [
    "### Train Val data split"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "Q8HLh-bNQmNz"
   },
   "outputs": [],
   "source": [
    "#np_train_all = np.clip(np_train_all/255, 0, 1)\n",
    "#X_test = np.clip(X_test/255, 0, 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "XqYjA-Ud3KmI"
   },
   "outputs": [],
   "source": [
    "X_train_ids, X_val_ids = (\n",
    "    train_test_split(df_train_mask.index.tolist(), \n",
    "                     test_size=0.20,\n",
    "                     stratify = df_train_mask.mask_pix,\n",
    "                     random_state=0)\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "GAWRi1bLpyM_"
   },
   "outputs": [],
   "source": [
    "'''with open('./data/df_train_img_iou.pickle', 'rb') as f:\n",
    "    df_train_img_iou = pickle.load(f)\n",
    "\n",
    "train_hard_img_id= (\n",
    "    [misc_data['np_train_all_ids'].index(e) for e in df_train_img_iou.loc[df_train_img_iou.type=='HARD'].id]\n",
    ")\n",
    "\n",
    "X_train_ids = np.setdiff1d(X_train_ids, train_hard_img_id)'''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "GEqXO7GM3KmN"
   },
   "outputs": [],
   "source": [
    "X_train = np_train_all[X_train_ids]\n",
    "X_val = np_train_all[X_val_ids]\n",
    "y_train = np_train_all_mask[X_train_ids]\n",
    "y_val = np_train_all_mask[X_val_ids]\n",
    "depth_train = (\n",
    "    misc_data['df_train_all_depth']\n",
    "    .reindex(np.array(misc_data['np_train_all_ids'])[X_train_ids])\n",
    ")\n",
    "depth_val = (\n",
    "    misc_data['df_train_all_depth']\n",
    "    .reindex(np.array(misc_data['np_train_all_ids'])[X_val_ids])\n",
    ")\n",
    "depth_test = (\n",
    "    misc_data['df_train_all_depth']\n",
    "    .reindex(np.array(misc_data['np_test_ids']))\n",
    ")\n",
    "#X_train_mean_img = X_train.mean(0).astype(np.float32)\n",
    "#X_train_mean_img = X_train.mean((0,1,2)).astype(np.float32)\n",
    "X_train_mean_img = np.clip(np_train_all/255, 0, 1).mean((0,1,2)).astype(np.float32)\n",
    "\n",
    "all_data = {\n",
    "    'X_train': X_train,\n",
    "    'X_val': X_val,\n",
    "    'y_train': y_train,\n",
    "    'y_val': y_val,\n",
    "    'X_test': X_test,\n",
    "    'X_train_mean_img': X_train_mean_img\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "train_sample_weight = train_all_sample_weight[X_train_ids]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "id": "3ZVs5X-EpyNS",
    "outputId": "8d884a3c-8a33-441b-c981-70457a75523c"
   },
   "outputs": [],
   "source": [
    "X_train_mean_img"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "id": "2L51fSDkpyNV",
    "outputId": "37e6f6c7-2586-4385-da4c-d69f5b20a777"
   },
   "outputs": [],
   "source": [
    "X_train.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "id": "zl5Q4dsOpyNa",
    "outputId": "b87353cc-c067-4198-efde-5828842c2ec8"
   },
   "outputs": [],
   "source": [
    "y_train.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "id": "koLKXAYPpyNd",
    "outputId": "d12409ef-e150-4044-82e5-930e536acb22"
   },
   "outputs": [],
   "source": [
    "depth_train.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "0bMOyfebQmON"
   },
   "outputs": [],
   "source": [
    "p = Pipeline_Salt()\n",
    "#p.skew(probability=1, magnitude=0.5)\n",
    "p.random_distortion(probability=0.5, grid_width=3, grid_height=3, magnitude=5)\n",
    "p.rotate(probability=0.5, max_left_rotation=10, max_right_rotation=10)\n",
    "p.zoom(probability=0.5, min_factor=1.0, max_factor=2.0)\n",
    "p.shear(probability=0.5, max_shear_left=10, max_shear_right=10)\n",
    "p.flip_left_right(probability=0.5)\n",
    "p.crop_by_size(probability=0.5, width=101, height=101, centre=False)\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "8eXIcYoDqVcF"
   },
   "source": [
    "### Create a Train Dataloader"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "uYerp5hjW5gu"
   },
   "outputs": [],
   "source": [
    "weighted_sampler = torch.utils.data.sampler.WeightedRandomSampler(train_sample_weight.values, depth_train.shape[0])\n",
    "\n",
    "train_data_params = {'batch_size': 32,\n",
    "                     'sampler': weighted_sampler,\n",
    "                     #'shuffle': True,\n",
    "                     'drop_last': True}\n",
    "\n",
    "val_data_params = {'batch_size': 32,\n",
    "                   'shuffle': True,\n",
    "                   'drop_last': False}\n",
    "\n",
    "train_dataLoader = (\n",
    "    DataLoader(SaltDataset(X_train, y_train, depth_train,\n",
    "                           X_train_mean_img, out_size=128,  out_ch=1,\n",
    "                           transform=p.torch_transform()), **train_data_params)\n",
    ")\n",
    "\n",
    "val_dataLoader = (\n",
    "    DataLoader(SaltDataset(X_val, y_val, depth_val, \n",
    "                           X_train_mean_img, out_size=128, out_ch=1), **val_data_params)\n",
    ")\n",
    "\n",
    "dataloaders = {'train': train_dataLoader, 'val':val_dataLoader}\n",
    "\n",
    "sample = iter(dataloaders['train']).__next__()\n",
    "\n",
    "assert sample[0].shape == torch.Size([train_data_params['batch_size'], 1, 128, 128])\n",
    "assert sample[1].shape == torch.Size([train_data_params['batch_size'], 101, 101])\n",
    "assert sample[2].shape == torch.Size([train_data_params['batch_size']])\n",
    "assert sample[3].shape == torch.Size([train_data_params['batch_size']])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "dp1YZ7D5QmOg"
   },
   "outputs": [],
   "source": [
    "i = 0\n",
    "for X_batch, y_batch, d_batch, X_id in dataloaders['train']:\n",
    "    i+=1\n",
    "    if i>20:\n",
    "        break\n",
    "    X_orig = X_train[X_id[0]].squeeze()/255\n",
    "    X_tsfm = X_batch[0,0].squeeze().cpu().detach().numpy()[13:114,13:114] + X_train_mean_img.squeeze()\n",
    "    y_orig = y_train[X_id[0]].squeeze()\n",
    "    y_tsfm = (y_batch[0].squeeze().cpu().detach().numpy())\n",
    "    plot_img_mask_pred([X_orig, X_tsfm, y_orig, y_tsfm],\n",
    "                       [f'X Original-{X_id[0]}', 'X Transformed', 'y Original', 'y Transformed'])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 35
    },
    "colab_type": "code",
    "id": "GbN1-S12btDL",
    "outputId": "b4faf5a2-0dcc-4944-afc1-ecbd634d73da"
   },
   "outputs": [],
   "source": [
    "X_train.shape"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "qS4kZWQnW5gw"
   },
   "source": [
    "### Create a Train Dataloader for sanity check"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "lP-yemq8pyOf"
   },
   "outputs": [],
   "source": [
    "#weighted_sampler = torch.utils.data.sampler.WeightedRandomSampler(depth_train['weight'][:8], 2)\n",
    "weighted_sampler = torch.utils.data.sampler.WeightedRandomSampler(train_sample_weight.values[:8], 2)\n",
    "train_data_params = {'batch_size': 2,\n",
    "                   'sampler': weighted_sampler}\n",
    "\n",
    "val_data_params = {'batch_size': 2,\n",
    "                   'shuffle': True,\n",
    "                   'drop_last': False}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "VEA7t3xaQmOo"
   },
   "outputs": [],
   "source": [
    "train_dataLoader = (\n",
    "    DataLoader(SaltDataset(X_train[:8], y_train[:8], depth_train[:8],\n",
    "                           X_train_mean_img, out_size=128, out_ch=1,\n",
    "                           transform=None), **train_data_params)\n",
    "                           #transform=p.torch_transform()), **data_params)\n",
    ")\n",
    "\n",
    "val_dataLoader = (\n",
    "    DataLoader(SaltDataset(X_val[:4], y_val[:4], depth_val[:4], \n",
    "                           X_train_mean_img, out_size=128, out_ch=1), **val_data_params)\n",
    ")\n",
    "\n",
    "dataloaders = {'train': train_dataLoader, 'val':val_dataLoader}\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "r2hyd9ryGROf"
   },
   "outputs": [],
   "source": [
    "t = iter(train_dataLoader).__next__()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "v34uY0GkGROl"
   },
   "outputs": [],
   "source": [
    "X_batch, y_batch, d_batch, X_id = t"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "3FS1aTgBpyOs"
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "GjWYq0PnjVlT"
   },
   "outputs": [],
   "source": [
    "def train_model(model, dataloaders, criterion1, criterion2, optimizer, scheduler, model_save_name, other_data={}, \n",
    "                num_epochs=25, print_every=2, save_model_every=None, save_log_every=None, log=get_logger('SaltNet'), loss2_weight=0):\n",
    "    #args = locals()\n",
    "    #args = {k:v.shape if isinstance(v, (torch.Tensor, np.ndarray)) else v for k,v in args.items()}\n",
    "    #args = {k:v.shape if isinstance(v, (torch.Tensor, np.ndarray)) else v for k,v in args.items()}\n",
    "    log.info('Start Training...')\n",
    "    #log.info('Passed parameters: {}'.format(args))\n",
    "\n",
    "    start = time.time()\n",
    "\n",
    "    if torch.cuda.is_available():\n",
    "        model.cuda()\n",
    "\n",
    "    best_model_wts = copy.deepcopy(model.state_dict())\n",
    "    best_model = None\n",
    "    best_iou = 0.0\n",
    "    all_losses = []\n",
    "    iter_count = 0\n",
    "    X_train = other_data['X_train']\n",
    "    X_val = other_data['X_val']\n",
    "    y_train = other_data['y_train']\n",
    "    y_val = other_data['y_val']\n",
    "    X_train_mean_img = other_data['X_train_mean_img']\n",
    "    mask_cutoff = 0.\n",
    "\n",
    "    for epoch in range(1, num_epochs+1):\n",
    "        log.info('Epoch {}/{}'.format(epoch, num_epochs))\n",
    "        log.info('-' * 20)\n",
    "        if save_log_every is not None:\n",
    "            if (epoch % save_log_every == 0):\n",
    "                push_log_to_git()\n",
    "        # Each epoch has a training and validation phase\n",
    "        for phase in ['train', 'val']:\n",
    "            if phase == 'train':\n",
    "                scheduler.step()\n",
    "                model.train()  # Set model to training mode\n",
    "            else:\n",
    "                model.eval()   # Set model to evaluate mode\n",
    "\n",
    "            epoch_loss1 = []\n",
    "            epoch_loss2 = []\n",
    "            pred_vs_true_epoch = []\n",
    "\n",
    "            for X_batch, y_batch, d_batch, X_id in dataloaders[phase]:\n",
    "                # zero the parameter gradients\n",
    "                optimizer.zero_grad()\n",
    "                with torch.set_grad_enabled(phase == 'train'):\n",
    "                    #y_pred, y_mask_pred = model(X_batch)\n",
    "                    y_pred = model(X_batch)\n",
    "                    pred_vs_true_epoch.append([y_pred, y_batch])\n",
    "                    \n",
    "                    # backward + optimize only if in training phase\n",
    "                    if phase == 'train':                        \n",
    "                        #from boxx import g\n",
    "                        #g()\n",
    "                        #y_batch_mask_pix = y_batch.sum((1,2))\n",
    "                        #sample_weight = torch.where((y_batch_mask_pix<202) | (y_batch_mask_pix>5000), torch.tensor(1.0).type(dtype), (101**2/y_batch_mask_pix))\n",
    "                        #sample_weight = torch.ones_like(y_batch) * sample_weight.reshape(-1,1,1)\n",
    "                        \n",
    "                        loss_1 = criterion1(y_pred, y_batch.float())      \n",
    "                        #loss_1 = F.binary_cross_entropy_with_logits(y_pred, y_batch.float(), weight=sample_weight)\n",
    "                        if (epoch % 30 == 0):\n",
    "                          loss2_weight = loss2_weight + 0.05\n",
    "                        loss_2 = loss2_weight * criterion2(y_pred, y_batch.float()) \n",
    "\n",
    "                        #print(f'loss_pix: {loss_pix}, loss_dice:{loss_dice}')\n",
    "                        loss = loss_1 + loss_2\n",
    "                        #loss = loss_pix\n",
    "                        all_losses.append(loss.item())\n",
    "                        epoch_loss1.append(loss_1.item())\n",
    "                        epoch_loss2.append(loss_2.item())\n",
    "                        \n",
    "                        loss.backward()\n",
    "                        optimizer.step()\n",
    "                        iter_count += 1\n",
    "                if (phase == 'train') & (iter_count % print_every == 0):\n",
    "                    iou_batch = calc_mean_iou(y_pred.ge(mask_cutoff), y_batch.float())\n",
    "                    iou_acc = calc_clf_accuracy(y_pred.ge(mask_cutoff), y_batch.float())\n",
    "\n",
    "                    log.info('Batch Loss: {:.4f}, Epoch loss_1: {:.4f}, Epoch loss_2: {:.4f}, Batch IOU: {:.4f}, Batch Acc: {:.4f} at iter {}, epoch {}, Time: {}'.format(\n",
    "                        np.mean(all_losses[-print_every:]), np.mean(epoch_loss1), np.mean(epoch_loss2), iou_batch, iou_acc, iter_count, epoch, timeSince(start))\n",
    "                    )\n",
    "                    #print(all_losses)\n",
    "                    X_orig = X_train[X_id[0]].squeeze()/255\n",
    "                    X_tsfm = X_batch[0,0].squeeze().cpu().detach().numpy()\n",
    "                    X_tsfm = transform.resize(X_tsfm, (128, 128), mode='constant', preserve_range=True)\n",
    "                    X_tsfm = X_tsfm[13:114,13:114] + X_train_mean_img.squeeze()\n",
    "                    #X_tsfm = X_batch[0][X_batch[0].sum((1,2)).argmax()].squeeze().cpu().detach().numpy()[:101,:101] + X_train_mean_img.squeeze()\n",
    "\n",
    "                    y_orig = y_train[X_id[0]].squeeze()\n",
    "                    y_tsfm = (y_batch[0].squeeze().cpu().detach().numpy())\n",
    "                    y_tsfm_pred =  y_pred[0].squeeze().gt(mask_cutoff)\n",
    "                    plot_img_mask_pred([X_orig, X_tsfm, y_orig, y_tsfm, y_tsfm_pred],\n",
    "                                       ['X Original', 'X Transformed', 'y Original', 'y Transformed', 'y Predicted'])\n",
    "\n",
    "            y_pred_epoch = torch.cat([e[0] for e in pred_vs_true_epoch])\n",
    "            y_true_epoch = torch.cat([e[1] for e in pred_vs_true_epoch])\n",
    "            #from boxx import g\n",
    "            #g()\n",
    "            mean_iou_epoch = calc_mean_iou(y_pred_epoch.ge(mask_cutoff), y_true_epoch.float())\n",
    "            mean_acc_epoch = calc_clf_accuracy(y_pred_epoch.ge(mask_cutoff), y_true_epoch.float())\n",
    "            log.info('{} Mean IOU: {:.4f}, Mean Acc: {:.4f}, Best Val IOU: {:.4f} at epoch {}'.format(phase, mean_iou_epoch, mean_acc_epoch, best_iou, epoch))\n",
    "            if phase == 'val' and mean_iou_epoch > best_iou:\n",
    "                best_iou = mean_iou_epoch\n",
    "                best_model_wts = copy.deepcopy(model.state_dict())\n",
    "                stats = {'best_iou': best_iou,\n",
    "                         'all_losses': all_losses,\n",
    "                         'iter_count': iter_count}\n",
    "                log.info(save_model_state_to_chunks(epoch, copy.deepcopy(model.state_dict()),\n",
    "                                                    copy.deepcopy(optimizer.state_dict()),\n",
    "                                                    copy.deepcopy(scheduler.state_dict()), stats, model_save_name, '.'))\n",
    "                best_model = (epoch, copy.deepcopy(model.state_dict()),\n",
    "                                                    copy.deepcopy(optimizer.state_dict()),\n",
    "                                                    copy.deepcopy(scheduler.state_dict()), stats, model_save_name, '.')\n",
    "                log.info('Best Val Mean IOU so far: {}'.format(best_iou))\n",
    "                # Visualize 1 val sample and predictions\n",
    "                X_orig = X_val[X_id[0]].squeeze()/255\n",
    "                y_orig = y_val[X_id[0]].squeeze()\n",
    "                y_pred2 =  y_pred[0].squeeze().gt(mask_cutoff)\n",
    "                plot_img_mask_pred([X_orig, y_orig, y_pred2],\n",
    "                                   ['Val X Original', 'Val y Original', 'Val y Predicted'])\n",
    "        if save_model_every is not None:\n",
    "            if (epoch % save_model_every == 0) | (epoch == num_epochs-1):\n",
    "                if (best_model is not None) and (best_iou>0.81):\n",
    "                    log.info(save_model_state_to_chunks(*best_model))                \n",
    "                    push_model_to_git(ckp_name=model_save_name)\n",
    "                    best_model = None\n",
    "                else:\n",
    "                    log.info(\"Skip pushing model to git as there's no improvement\")\n",
    "\n",
    "    # load best model weights\n",
    "    model.load_state_dict(best_model_wts)\n",
    "    log.info('-' * 20)\n",
    "    time_elapsed = time.time() - start\n",
    "    log.info('Training complete in {:.0f}m {:.0f}s'.format(\n",
    "        time_elapsed // 60, time_elapsed % 60))\n",
    "    log.info('Best val IOU: {:4f}'.format(best_iou))\n",
    "\n",
    "    return model"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "dasEpZc0QmOt"
   },
   "source": [
    "## Train the model using a small data set to see if it can overfit"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "7SbmYNEfkWQB",
    "scrolled": true
   },
   "outputs": [],
   "source": [
    "saltnet = UNet(n_channels=1, n_classes=1, bilinear=True, logits=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "6PIaW0ComzkI"
   },
   "outputs": [],
   "source": [
    "#saltnet = resnet34unet(in_ch=3, bilinear=False, pretrained=False)\n",
    "\n",
    "loss_fn_bce = nn.BCEWithLogitsLoss(pos_weight=torch.tensor(2.0))\n",
    "#loss_focal = FocalLoss(0.25, 2, logits=True)\n",
    "loss_lovasz_hinge = LovaszHingeLoss()\n",
    "\n",
    "optimizer = torch.optim.Adam(saltnet.parameters(), lr=0.01)\n",
    "\n",
    "scheduler = lr_scheduler.StepLR(optimizer, step_size=50, gamma=0.1)\n",
    "\n",
    "model_save_name = None\n",
    "\n",
    "# Test Run\n",
    "trained_model = train_model(saltnet, dataloaders, loss_fn_bce, loss_lovasz_hinge, optimizer, scheduler, model_save_name, \n",
    "                other_data=all_data, num_epochs=100, print_every=1, save_model_every=None, save_log_every=None, log=log, loss2_weight=0.005)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "zJ3DJ4hAQmOw"
   },
   "source": [
    "## Train the full with full dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 35
    },
    "colab_type": "code",
    "id": "AZkSxKV2sIkN",
    "outputId": "d97f33ec-dd0d-4abb-b491-1ca3005bb3eb"
   },
   "outputs": [],
   "source": [
    "log.info('Split data to train and test using stratification based on pix intensity. Over sampled low mask images due to crop.')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "z3treVXh_Uha"
   },
   "outputs": [],
   "source": [
    "model_config = '''\n",
    "\n",
    "'''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 284
    },
    "colab_type": "code",
    "id": "a563SYmgwbX6",
    "outputId": "8c4a35f8-767d-46ab-885c-ea9c54099882"
   },
   "outputs": [],
   "source": [
    "log.info(model_config)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 195
    },
    "colab_type": "code",
    "id": "u8EUxk8UQmOx",
    "outputId": "9a6aae74-eb55-459c-e3a0-9ef07e0d8277"
   },
   "outputs": [],
   "source": [
    "saltnet = UNet(n_channels=1, n_classes=1, bilinear=True, logits=True)\n",
    "loss_fn_bce = nn.BCEWithLogitsLoss(pos_weight=torch.tensor(2.0))\n",
    "#loss_focal = FocalLoss(0.25, 2, logits=True)\n",
    "loss_lovasz_hinge = LovaszHingeLoss()\n",
    "optimizer = torch.optim.Adam(saltnet.parameters(), lr=0.01)\n",
    "scheduler = lr_scheduler.StepLR(optimizer, step_size=10, gamma=0.8)\n",
    "\n",
    "model_save_name = f'../salt_net/Unet_bce_loss_lovasz_loss_data_preprocess_{get_current_time_as_fname()}.ckp'\n",
    "log.info(model_save_name)\n",
    "\n",
    "# Test Run\n",
    "trained_model = train_model(saltnet, dataloaders, loss_fn_bce, loss_lovasz_hinge, optimizer, scheduler, model_save_name, \n",
    "                other_data=all_data, num_epochs=300, print_every=50, save_model_every=20, save_log_every=2, log=log, loss2_weight=0.1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "-P-jcOQMjL7w"
   },
   "outputs": [],
   "source": [
    "## Fine tune"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "id": "6gH3StpeyZoc",
    "outputId": "83d2e137-31e0-46d9-a123-970ade7a4e2f"
   },
   "outputs": [],
   "source": [
    "log.info('Change data transformer to zoop up to 1.05, disable distortion, using Focal Loss and SGD with lr 0.001')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "i1G7CTpsySfm"
   },
   "outputs": [],
   "source": [
    "model_config = '''\n",
    "p = Pipeline_Salt()\n",
    "#p.skew(probability=1, magnitude=0.5)\n",
    "#p.random_distortion(probability=0.5, grid_width=3, grid_height=3, magnitude=5)\n",
    "p.rotate(probability=0.5, max_left_rotation=10, max_right_rotation=10)\n",
    "p.zoom(probability=0.5, min_factor=1.0, max_factor=1.05)\n",
    "p.shear(probability=0.5, max_shear_left=10, max_shear_right=10)\n",
    "p.flip_left_right(probability=0.5)\n",
    "p.crop_by_size(probability=0.5, width=101, height=101, centre=False)\n",
    "\n",
    "weighted_sampler = torch.utils.data.sampler.WeightedRandomSampler(depth_train['weight'].values, depth_train.shape[0])\n",
    "\n",
    "train_data_params = {'batch_size': 32,\n",
    "                     'sampler': weighted_sampler,\n",
    "                    'drop_last': True}\n",
    "\n",
    "val_data_params = {'batch_size': 32,\n",
    "                   'shuffle': True,\n",
    "                   'drop_last': False}\n",
    "\n",
    "train_dataLoader = (\n",
    "    DataLoader(SaltDataset(X_train, y_train, depth_train,\n",
    "                           X_train_mean_img, out_size=128,  out_ch=1,\n",
    "                           transform=p.torch_transform()), **train_data_params)\n",
    ")\n",
    "\n",
    "val_dataLoader = (\n",
    "    DataLoader(SaltDataset(X_val, y_val, depth_val, \n",
    "                           X_train_mean_img, out_size=128, out_ch=1), **val_data_params)\n",
    ")\n",
    "\n",
    "dataloaders = {'train': train_dataLoader, 'val':val_dataLoader}\n",
    "\n",
    "sample = iter(dataloaders['train']).__next__()\n",
    "'''"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 605
    },
    "colab_type": "code",
    "id": "jLGTRHvqzIMm",
    "outputId": "a509441a-be02-494b-fca6-f66efe811059"
   },
   "outputs": [],
   "source": [
    "log.info(model_config)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "WZj2ujOdjrr6"
   },
   "outputs": [],
   "source": [
    "p = Pipeline_Salt()\n",
    "#p.skew(probability=1, magnitude=0.5)\n",
    "#p.random_distortion(probability=0.5, grid_width=3, grid_height=3, magnitude=5)\n",
    "p.rotate(probability=0.5, max_left_rotation=10, max_right_rotation=10)\n",
    "p.zoom(probability=0.5, min_factor=1.0, max_factor=1.05)\n",
    "p.shear(probability=0.5, max_shear_left=10, max_shear_right=10)\n",
    "p.flip_left_right(probability=0.5)\n",
    "p.crop_by_size(probability=0.5, width=101, height=101, centre=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "9srB0xzQxwY2"
   },
   "outputs": [],
   "source": [
    "weighted_sampler = torch.utils.data.sampler.WeightedRandomSampler(depth_train['weight'].values, depth_train.shape[0])\n",
    "\n",
    "train_data_params = {'batch_size': 32,\n",
    "                     'sampler': weighted_sampler,\n",
    "                    'drop_last': True}\n",
    "\n",
    "val_data_params = {'batch_size': 32,\n",
    "                   'shuffle': True,\n",
    "                   'drop_last': False}\n",
    "\n",
    "train_dataLoader = (\n",
    "    DataLoader(SaltDataset(X_train, y_train, depth_train,\n",
    "                           X_train_mean_img, out_size=128,  out_ch=1,\n",
    "                           transform=p.torch_transform()), **train_data_params)\n",
    ")\n",
    "\n",
    "val_dataLoader = (\n",
    "    DataLoader(SaltDataset(X_val, y_val, depth_val, \n",
    "                           X_train_mean_img, out_size=128, out_ch=1), **val_data_params)\n",
    ")\n",
    "\n",
    "dataloaders = {'train': train_dataLoader, 'val':val_dataLoader}\n",
    "\n",
    "sample = iter(dataloaders['train']).__next__()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "MfnNZyIMjr2z"
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 118
    },
    "colab_type": "code",
    "id": "y1TB1NlPx-_p",
    "outputId": "e4bebde0-33d8-44f1-92fa-2ac2f7226766"
   },
   "outputs": [],
   "source": [
    "saltnet = loaded_model\n",
    "loss_fn_bce = nn.BCEWithLogitsLoss()\n",
    "loss_focal = FocalLoss(0.25, 2.5, logits=True)\n",
    "loss_lovasz_hinge = LovaszHingeLoss()\n",
    "optimizer = torch.optim.SGD(saltnet.parameters(), lr=0.001)\n",
    "scheduler = lr_scheduler.StepLR(optimizer, step_size=10, gamma=0.8)\n",
    "\n",
    "model_save_name = f'../salt_net/Unet_focal_loss_lovasz_loss_data_preprocess_finetune_{get_current_time_as_fname()}.ckp'\n",
    "log.info(model_save_name)\n",
    "\n",
    "# Test Run\n",
    "trained_model = train_model(saltnet, dataloaders, loss_fn_bce, loss_lovasz_hinge, optimizer, scheduler, model_save_name, \n",
    "                other_data=all_data, num_epochs=150, print_every=50, save_model_every=20, save_log_every=2, log=log, loss2_weight=0.1)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "9MW3YwaZQmOz"
   },
   "source": [
    "## Load Trained Model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 84
    },
    "colab_type": "code",
    "id": "LIRv-uXQGROz",
    "outputId": "af0bd678-45be-4b72-91c2-33d02c67ffd1"
   },
   "outputs": [],
   "source": [
    "loaded_model = UNet(n_channels=1, n_classes=1, bilinear=True, logits=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 504
    },
    "colab_type": "code",
    "id": "MDpBS2c9ePeW",
    "outputId": "3f1d3102-0a0f-4be2-fd77-c96f71a682b3"
   },
   "outputs": [],
   "source": [
    "ls"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "cuoeW6MLd439"
   },
   "outputs": [],
   "source": [
    "model_file_suffix = \"Unet_bce_loss_lovasz_loss_data_preprocess_2018_09_10_00_17_44.ckp\"\n",
    "model_state_dict = torch.load(join_files(model_file_suffix, '.', returnFileObject=True, removeChunks=False))\n",
    "loaded_model.load_state_dict(model_state_dict['model'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "PbgxXtYH3KpR"
   },
   "source": [
    "### Make Predictions on validation set"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "W0cFNMM0QmO4"
   },
   "source": [
    "### Set model to evaluation mode"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "izo8iByg3KpP"
   },
   "outputs": [],
   "source": [
    "loaded_model.eval()\n",
    "assert loaded_model.training == False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "zfdN-P-j3KpS"
   },
   "outputs": [],
   "source": [
    "val_dataLoader = DataLoader(SaltDataset(X_val, y_val, depth_val, X_train_mean_img, out_size=128), batch_size=16)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "7M0ZHG7o6swA"
   },
   "outputs": [],
   "source": [
    "if torch.cuda.is_available():\n",
    "    loaded_model.cuda()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 50
    },
    "colab_type": "code",
    "id": "JMuArCUd3KpU",
    "outputId": "c16b4fbd-2176-481c-ece0-3bb37c92e0da"
   },
   "outputs": [],
   "source": [
    "y_val_pred = []\n",
    "\n",
    "with torch.no_grad():\n",
    "    for X_val_batch, y_val_batch, depth_val_batch, X_val_id_batch in val_dataLoader:\n",
    "        y_val_pred.append(loaded_model(X_val_batch))\n",
    "y_val_pred = torch.cat(y_val_pred)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "nxNTal6nS8Za"
   },
   "outputs": [],
   "source": [
    "train_dataLoader = DataLoader(SaltDataset(X_train, y_train, depth_train, X_train_mean_img, out_size=128), batch_size=16)\n",
    "y_train_pred = []\n",
    "\n",
    "with torch.no_grad():\n",
    "    for X_train_batch, y_train_batch, depth_train_batch, X_train_id_batch in train_dataLoader:\n",
    "        y_train_pred.append(loaded_model(X_train_batch))\n",
    "y_train_pred = torch.cat(y_train_pred)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 2129
    },
    "colab_type": "code",
    "id": "2_DJpL1o3KpY",
    "outputId": "cf12bb61-5486-4120-cc6a-05bff9ec9347"
   },
   "outputs": [],
   "source": [
    "for i in range(10):\n",
    "    rand_id = np.random.choice(X_val_id_batch)\n",
    "    print(f'Image ID: {rand_id}')\n",
    "    val_img = X_val[rand_id]/255\n",
    "    val_mask = y_val[rand_id]\n",
    "    val_mask_pred = y_val_pred.ge(0.5)[rand_id]\n",
    "    plot_img_mask_pred([val_img, val_mask, val_mask_pred], range(3), img_per_line=3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "fkD6eqk9ghEe"
   },
   "outputs": [],
   "source": [
    "for i in range(10):\n",
    "    rand_id = np.random.choice(X_train_id_batch)\n",
    "    print(f'Image ID: {rand_id}')\n",
    "    img = X_train[rand_id]/255\n",
    "    mask = y_train[rand_id]\n",
    "    mask_pred = y_train_pred.ge(0.5)[rand_id]\n",
    "    plot_img_mask_pred([img, mask, mask_pred], range(3), img_per_line=3)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "aFW4BqZx8VzV"
   },
   "outputs": [],
   "source": [
    "ZERO_MASK_CUTOFF = 50\n",
    "MASK_CUTOFF = 0."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "id": "vMbnI4J6Jkr1",
    "outputId": "d899b018-d60a-4bc4-e38b-701bcf42d5b7"
   },
   "outputs": [],
   "source": [
    "y_val_pred_adj = adjust_predictions(ZERO_MASK_CUTOFF, X_val, y_val_pred.gt(MASK_CUTOFF), y_val.squeeze())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "id": "aPOBqHPDVbzS",
    "outputId": "104fd9fd-2a8a-4182-a9af-a9ec1f8c52ca"
   },
   "outputs": [],
   "source": [
    "y_val_pred_adj = adjust_predictions(0, X_val, y_val_pred.gt(0.1), y_val.squeeze())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 1025
    },
    "colab_type": "code",
    "id": "kgcUBfKx8rpd",
    "outputId": "7a321183-1a26-4d10-fb42-a8192ee1e675"
   },
   "outputs": [],
   "source": [
    "results=[]\n",
    "for cut_off in range(0, 300, 10):\n",
    "  print(cut_off)\n",
    "  results.append(calc_mean_iou(adjust_predictions(cut_off, X_val, y_val_pred.gt(MASK_CUTOFF), y_val.squeeze()), y_val.squeeze()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "id": "KcfUIfJyNna6",
    "outputId": "bcd59d9c-000b-4bbb-99f5-86adb1480576"
   },
   "outputs": [],
   "source": [
    "range(0, 300, 10)[np.argmax(results)]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "w1j58cIWfqxj"
   },
   "outputs": [],
   "source": [
    "results"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "hmT8DPBnGRPh"
   },
   "outputs": [],
   "source": [
    "y_val_pred_adj = adjust_predictions(ZERO_MASK_CUTOFF, X_val, y_val_pred.gt(MASK_CUTOFF), y_val.squeeze())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "GCR_6IO1g7xE"
   },
   "outputs": [],
   "source": [
    "y_train_pred_adj = adjust_predictions(ZERO_MASK_CUTOFF, X_train, y_train_pred.gt(MASK_CUTOFF), y_train.squeeze())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "IeXdGnrPgIDe"
   },
   "outputs": [],
   "source": [
    "results=[]\n",
    "for cut_off in range(0, 300, 10):\n",
    "  print(cut_off)\n",
    "  results.append(calc_mean_iou(adjust_predictions(cut_off, X_train, y_train_pred.gt(MASK_CUTOFF), y_train.squeeze()), y_train.squeeze()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "vQErtiLSgZPh"
   },
   "outputs": [],
   "source": [
    "range(0, 3000, 10)[np.argmax(results)]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "o1oSze9o3Kp_"
   },
   "source": [
    "## Make predictions on test set"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "c-M7XAbPhcUm"
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "4xzKpwGrhcOo"
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "X6ocZkIAS8Zf"
   },
   "outputs": [],
   "source": [
    "#test_dataLoader = DataLoader(SaltDataset(np_test[:10], None, depth_test, X_train_mean_img), batch_size=4)\n",
    "test_dataLoader = DataLoader(SaltDataset(X_test, np.zeros_like(X_test), depth_test, X_train_mean_img, out_size=128), batch_size=16)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 50
    },
    "colab_type": "code",
    "id": "ChMRx1kh3KqE",
    "outputId": "536382b8-6a33-4695-8618-1c34fc40b2b5"
   },
   "outputs": [],
   "source": [
    "y_test_pred_raw = []\n",
    "with torch.no_grad():\n",
    "    for X_test_batch, y_test_batch, depth_test_batch, X_test_id_batch in test_dataLoader:\n",
    "        y_test_pred_raw.append(loaded_model(X_test_batch))\n",
    "y_test_pred = torch.cat(y_test_pred_raw)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "XiRFXS8K3KqI"
   },
   "source": [
    "### Show segmentation masks for a few images"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "Z8_mXXfA3KqI"
   },
   "outputs": [],
   "source": [
    "for i in range(10):\n",
    "    rand_id = np.random.choice(X_test_id_batch)\n",
    "    print(f'Image ID: {rand_id}')\n",
    "    img = X_test[rand_id]/255\n",
    "    mask_pred = y_test_pred.ge(0.5)[rand_id]\n",
    "    plot_img_mask_pred([img, mask_pred], range(2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "OnjDYjvp3KqK"
   },
   "source": [
    "### Adjust predictions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "btYQ-5_PlTBN"
   },
   "outputs": [],
   "source": [
    " ZERO_MASK_CUTOFF = 60"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "jojQbvhtS8Zn"
   },
   "outputs": [],
   "source": [
    "y_test_pred_adj = adjust_predictions(ZERO_MASK_CUTOFF, X_test, y_test_pred.gt(MASK_CUTOFF))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "colab_type": "text",
    "id": "M52jKbLA3KqM"
   },
   "source": [
    "### Encode predictions using RLE(Run Length Encoding) method"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "uW0shno43KqM"
   },
   "outputs": [],
   "source": [
    "y_test_pred_rle = rle_encoder3d(y_test_pred_adj)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "id": "sdPQnJqUS8Zr",
    "outputId": "0340eb30-1d75-4dbe-ca9f-b47841cf58da"
   },
   "outputs": [],
   "source": [
    "y_test_pred_adj.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "9GaCKooz3KqN"
   },
   "outputs": [],
   "source": [
    "df_test_rle = pd.DataFrame(index=misc_data['np_test_ids'], data=y_test_pred_rle).reset_index()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "loaXDzkM3KqQ"
   },
   "outputs": [],
   "source": [
    "df_test_rle.columns = ['id', 'rle_mask']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "id": "j_iM1oRr3KqS",
    "outputId": "44d057e8-c49b-425a-95b4-0e7523bebbe7"
   },
   "outputs": [],
   "source": [
    "df_test_rle[df_test_rle.rle_mask==''].shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 34
    },
    "colab_type": "code",
    "id": "BJzlb6q7cCM-",
    "outputId": "309b4e17-8d3f-46b4-e092-1716498919ee"
   },
   "outputs": [],
   "source": [
    "df_test_rle.shape"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "09CFLpNL3KqY"
   },
   "outputs": [],
   "source": [
    "df_test_rle.to_csv(f'submission_{get_current_time_as_fname()}.csv', index=False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {
     "base_uri": "https://localhost:8080/",
     "height": 538
    },
    "colab_type": "code",
    "id": "s-yT6TajkR6U",
    "outputId": "c65e2a1e-e612-4b0d-9e6e-73c3a1acd878"
   },
   "outputs": [],
   "source": [
    "ls"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "o_1B43JYGRQI"
   },
   "outputs": [],
   "source": [
    "from google.colab import files\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "yV3mMqgRkYBT"
   },
   "outputs": [],
   "source": [
    "files.download('submission_2018_09_10_14_22_40.csv') "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "x38qXbAkmFSH"
   },
   "outputs": [],
   "source": [
    "import numpy as np"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "KjPkHzKBmz7s"
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "_zUtOPXwmz7y"
   },
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "colab": {},
    "colab_type": "code",
    "id": "kSe7dmyMqnPF"
   },
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "accelerator": "GPU",
  "colab": {
   "name": "salt_model_data_loader_V3.ipynb",
   "provenance": [],
   "version": "0.3.2"
  },
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.2"
  },
  "toc": {
   "base_numbering": 1,
   "nav_menu": {},
   "number_sections": true,
   "sideBar": true,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": false,
   "toc_position": {},
   "toc_section_display": true,
   "toc_window_display": false
  },
  "varInspector": {
   "cols": {
    "lenName": 16,
    "lenType": 16,
    "lenVar": 40
   },
   "kernels_config": {
    "python": {
     "delete_cmd_postfix": "",
     "delete_cmd_prefix": "del ",
     "library": "var_list.py",
     "varRefreshCmd": "print(var_dic_list())"
    },
    "r": {
     "delete_cmd_postfix": ") ",
     "delete_cmd_prefix": "rm(",
     "library": "var_list.r",
     "varRefreshCmd": "cat(var_dic_list()) "
    }
   },
   "types_to_exclude": [
    "module",
    "function",
    "builtin_function_or_method",
    "instance",
    "_Feature"
   ],
   "window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
